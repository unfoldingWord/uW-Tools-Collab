# translationCore Format Handling Guide

## Introduction

This guide provides detailed documentation for handling repositories created by translationCore desktop application. These repositories use a different manifest format than standard Resource Containers and require special processing.

**Key Characteristics:**
- Single book focus (not complete Bible)
- JSON manifest format with translationCore-specific fields
- Multiple USFM file variations per book
- Tool-specific metadata and configuration

## Identification

### Manifest Detection

**File**: `manifest.json`, `manifest.yaml`, or `manifest.yml` (any extension possible)

> **⚠️ Critical**: Format is determined by **content structure**, not file extension. A translationCore manifest could be in YAML format, and a Resource Container could be in JSON format.

**Key Identifiers**:
```json
{
  "tc_version": 8,
  "generator": {"name": "tc-desktop"},
  "project": {"id": "jon", "name": "Jonah"},
  "resource": {"id": "glt", "name": "Gateway Language Translation"}
}
```

**How to Detect translationCore Format**:

**Step 1: Look for Strong Indicators**
- Check if the manifest has a `tc_version` field - if yes, it's definitely translationCore
- Check if there's a `generator` field with `name` set to "tc-desktop" - if yes, it's translationCore

**Step 2: Look for Structural Pattern** (if step 1 didn't find anything)
- The manifest should have these fields: `project`, `resource`, and `target_language`
- The manifest should NOT have these fields: `dublin_core`, `meta`, or `resource_container`
- If this pattern matches, it's likely translationCore

**Step 3: Make Decision**
- If either step 1 or step 2 indicates translationCore, treat it as translationCore format
- Otherwise, it's not a translationCore repository

**How to Find and Identify Any Manifest Format**:

**Step 1: Find Manifest Files**
- Get the list of all files in the repository root directory
- Look for files named: `manifest.json`, `manifest.yaml`, `manifest.yml`, `metadata.json`, `metadata.yaml`, or `metadata.yml`
- Remember: the file extension doesn't tell you the format - you need to check the content

**Step 2: Try Each Manifest File**
- For each manifest file you found:
  - Download the file content from the repository
  - If the content is base64 encoded, decode it first
  - Parse the content using the right parser:
    - If filename ends with `.json` → use JSON parser
    - If filename ends with `.yaml` or `.yml` → use YAML parser

**Step 3: Check the Content Structure**
- Apply the format detection steps (like the translationCore detection above)
- If you recognize the format, you're done - use that format info
- If not recognized, try the next manifest file

**Step 4: Handle Results**
- If you found a recognized format, use that information to process the repository
- If no manifest files had recognized formats, treat it as an unknown repository type

## Manifest Structure

### Core Fields

Based on analysis of real translationCore repositories:

```json
{
  "project": {
    "id": "jon",           // Book identifier (3-letter code)
    "name": "Jonah"        // Human-readable book name
  },
  "resource": {
    "id": "glt",           // Resource type (glt, ust, tn, etc.)
    "name": "Gateway Language Translation"
  },
  "target_language": {
    "id": "es-419",        // BCP 47 language code
    "name": "Español Latin America",
    "direction": "ltr",    // Text direction
    "book": {
      "name": "Jonás"      // Localized book name
    }
  },
  "generator": {
    "name": "tc-desktop",  // Tool identifier
    "build": "3.6.6"       // Tool version
  },
  "tc_version": 8,         // translationCore format version
  "package_version": 7,    // Package format version
  "license": "CC BY-SA 4.0"
}
```

### Dependency Information

```json
{
  "source_translations": [
    {
      "language_id": "en",
      "resource_id": "ult",
      "checking_level": "3",
      "date_modified": "2025-03-31T18:31:45.701Z",
      "version": "85"
    }
  ],
  "tsv_relation": [
    "en/ult", "en/ust", "en/ta", "en/tq", "en/tw",
    "hbo/uhb?v=2.1.30", "el-x-koine/ugnt?v=0.34"
  ]
}
```

### Tool-Specific Metadata

```json
{
  "toolsSelectedGLs": {
    "translationNotes": "en",
    "translationWords": "en", 
    "wordAlignment": "en"
  },
  "toolsSelectedOwners": {
    "translationNotes": "unfoldingWord",
    "translationWords": "unfoldingWord",
    "wordAlignment": "unfoldingWord"
  },
  "tc_edit_version": "3.6.6",
  "tc_min_compatible_version": "3.6.6"
}
```

## File Structure Patterns

### Repository Structure Analysis

Based on analysis of [es-419_glt_jon_book](https://git.door43.org/abelper8/es-419_glt_jon_book):

```
es-419_glt_jon_book/
├── 📄 manifest.json                    # translationCore manifest (required)
├── 📄 settings.json                    # translationCore app settings
├── 📄 LICENSE.md                       # License file
├── 📄 jon.usfm                         # Main book file (simple name)
├── 📄 es-419_glt_jon_book.usfm        # Complete book file (full name)
├── 📄 es-419_tpl_jon_book.usfm        # Alternative resource version
└── 📁 .apps/                           # translationCore application data
    └── 📁 translationCore/
        ├── 📄 alignmentData/           # Word alignment data
        ├── 📄 checkData/               # Quality check data
        └── 📄 selectionsData/          # User selections
```

### File Types and Purposes

| File Pattern | Purpose | Example | Analysis |
|--------------|---------|---------|----------|
| `manifest.json` | Project metadata | Required | translationCore format detection |
| `{book}.usfm` | Simple book file | `jon.usfm` | Main content, ~15KB |
| `{lang}_{resource}_{book}_book.usfm` | Complete book | `es-419_glt_jon_book.usfm` | Full formatted version |
| `{lang}_{alt}_{book}_book.usfm` | Alternative version | `es-419_tpl_jon_book.usfm` | Different resource type |
| `settings.json` | App configuration | Optional | translationCore settings |
| `LICENSE.md` | License information | Standard | CC BY-SA 4.0 |
| `.apps/translationCore/` | Tool data | Tool-specific | Alignment, checks, selections |

### Content Analysis Findings

**USFM Files Structure**:
- **Chapters**: Typically 1-4 chapters per book (varies by book)
- **Verses**: 10-50+ verses depending on book length
- **Alignment Data**: Word-level alignment markers present
- **USFM Markers**: Standard Bible markup (`\id`, `\c`, `\v`, `\p`, `\s`)
- **Alignment Markers**: `\zaln-s`, `\zaln-e`, `\w`, `\w*`

**Multiple USFM Variations**:
- **Simple format**: `{book}.usfm` - Basic book content
- **Full format**: `{lang}_{resource}_{book}_book.usfm` - Complete with metadata
- **Alternative**: Different resource types (glt vs tpl vs other)

### How to Find translationCore Files

**Step 1: Get Key Information from Manifest**
- Extract the book ID from `manifest.project.id` (like "jon" for Jonah)
- Extract the language ID from `manifest.target_language.id` (like "es-419")
- Extract the resource ID from `manifest.resource.id` (like "glt")

**Step 2: Find USFM Files**
- Look through all repository files for files ending with ".usfm"
- Keep only the USFM files that relate to your book by checking if the filename:
  - Equals the book ID + ".usfm" (like "jon.usfm"), OR
  - Contains the book ID + "_book" (like "jon_book"), OR  
  - Contains the language + "_" + resource pattern (like "es-419_glt")

**Step 3: Categorize the USFM Files**
- **Simple file**: Look for a file named exactly "{book}.usfm" (like "jon.usfm")
- **Complete file**: Look for files containing "{book}_book" in the name
- **Alternative files**: Any other USFM files that contain the book ID but don't fit the above patterns

**Step 4: Check for Additional Files**
- Look for "settings.json" - this contains translationCore app settings
- Look for ".apps" directory - this contains tool-specific data like alignment information

**Step 5: Organize Your Findings**
- You now have a complete picture of the repository structure
- You know which USFM file to use (prefer complete, then simple, then alternatives)
- You know what additional features are available (settings, tool data)

**How to Categorize USFM Files**:

When you find multiple USFM files for the same book, here's how to understand what each one is for:

- **Simple file**: If the filename is just "{book}.usfm" (like "jon.usfm"), this is the basic version
- **Complete file**: If the filename contains "{book}_book" (like "es-419_glt_jon_book.usfm"), this is the full version with all metadata
- **Alternative file**: If the filename contains the book ID but doesn't match the above patterns, it's probably an alternative version or different resource type
- **Unknown**: If the filename doesn't contain the book ID at all, it might not belong to this book

### Advanced Directory Analysis

**`.apps/translationCore/` Directory Structure**:

Based on translationCore application patterns, this directory typically contains:

```
.apps/translationCore/
├── 📁 alignmentData/
│   ├── 📄 {book}/
│   │   ├── 📄 {chapter}/
│   │   │   └── 📄 alignmentData.json
│   │   └── 📄 index.js
│   └── 📄 index.js
├── 📁 checkData/
│   ├── 📄 {tool}/
│   │   ├── 📄 {book}/
│   │   │   └── 📄 {chapter}.json
│   │   └── 📄 index.js
│   └── 📄 index.js
├── 📁 selectionsData/
│   ├── 📄 {tool}/
│   │   ├── 📄 {book}/
│   │   │   └── 📄 {chapter}.json
│   │   └── 📄 index.js
│   └── 📄 index.js
└── 📄 index.js
```

**Purpose of .apps/ Directory**:
- **alignmentData**: Word-level alignment between source and target
- **checkData**: Quality assurance check results and notes
- **selectionsData**: User selections and highlighted text
- **index.js files**: Data structure indexes for quick access

### Content Type Analysis

**USFM File Content Patterns**:

*Example from `jon.usfm` (Jonah):*
```usfm
\id JON unfoldingWord® Literal Text
\usfm 3.0
\ide UTF-8
\h Jonah
\toc1 The Book of Jonah
\toc2 Jonah
\toc3 Jon
\mt Jonah

\c 1
\p
\v 1 \zaln-s |x-strong="H01961" x-lemma="הָיָה" x-morph="He,Vqw3ms" x-occurrence="1" x-occurrences="1" x-content="וַֽיְהִי"\*\w And|x-occurrence="1" x-occurrences="1"\w*\zaln-e\* \zaln-s |x-strong="H01697" x-lemma="דָּבָר" x-morph="He,Ncmsc" x-occurrence="1" x-occurrences="1" x-content="דְבַר"\*\w the|x-occurrence="1" x-occurrences="1"\w* \w word|x-occurrence="1" x-occurrences="1"\w*\zaln-e\* \zaln-s |x-strong="H03068" x-lemma="יְהֹוָה" x-morph="He,Np" x-occurrence="1" x-occurrences="1" x-content="יְהוָ֖ה"\*\w of|x-occurrence="1" x-occurrences="1"\w* \w Yahweh|x-occurrence="1" x-occurrences="1"\w*\zaln-e\*...
```

**Key Characteristics**:
- **Word Alignment**: Extensive `\zaln-s` and `\zaln-e` markers
- **Strong's Numbers**: Hebrew/Greek concordance references
- **Morphology**: Grammatical parsing information
- **Occurrence Tracking**: Word occurrence counting for alignment

**File Size Patterns**:
- **Small books** (Jonah, Philemon): 10-20 KB
- **Medium books** (Ephesians, Philippians): 20-50 KB  
- **Large books** (Genesis, Psalms): 100+ KB

### Tool-Specific Files

**settings.json Structure**:
```json
{
  "userPreferences": {
    "locale": "es-419",
    "fontSize": 14,
    "theme": "light"
  },
  "projectSettings": {
    "bookId": "jon",
    "resourceId": "glt",
    "targetLanguage": "es-419"
  },
  "toolSettings": {
    "wordAlignment": {...},
    "translationNotes": {...}
  }
}
```

## Processing Guidelines

### 1. How to Process a translationCore Repository

**Step 1: Get the File List**
- Get the complete list of files and directories in the repository root
- This shows you what content is available

**Step 2: Find the Manifest File**
- Look for files named: "manifest.json", "manifest.yaml", or "manifest.yml"
- Remember: any of these could contain translationCore format

**Step 3: Read and Parse the Manifest**
- Download the manifest file content from the repository
- If the content is base64 encoded, decode it first
- Parse it using the appropriate parser (JSON for .json files, YAML for .yaml/.yml files)

**Step 4: Verify It's translationCore Format**
- Apply the translationCore detection steps from the identification section above
- If it's not translationCore format, you'll need to handle it as a different type

**Step 5: Process the Repository**
- Now you can extract all the information you need from the manifest and file structure

### 2. File Access Patterns

**Single Book Scope**:
- translationCore projects focus on one book at a time
- Multiple USFM files may exist for the same book
- Use repository file listing to find actual files

**File Priority**:
1. Look for `{book}.usfm` (simple format)
2. Look for `{lang}_{resource}_{book}_book.usfm` (complete format)
3. Check for numbered chapter files (`01.usfm`, `02.usfm`)

### 3. Dependency Resolution

**Use `tsv_relation` field** (not `relation`):
```json
{
  "tsv_relation": [
    "en/ult",           // Source literal translation
    "en/ust",           // Source simplified translation  
    "en/ta",            // Translation Academy
    "en/tq",            // Translation Questions
    "en/tw",            // Translation Words
    "hbo/uhb?v=2.1.30", // Hebrew Bible with version
    "el-x-koine/ugnt?v=0.34" // Greek NT with version
  ]
}
```

### 4. Content Processing Strategy

**How to Select the Primary Content File**:
- First, look for the complete version (files with "_book" in the name) - this is the most comprehensive
- If no complete version exists, use the simple version (just "{book}.usfm")
- If neither exists, use the first alternative file you found as a fallback
- If no suitable files exist at all, there's an issue with the repository structure

**How to Handle Multiple USFM Files**:
- For each USFM file you found, note its name, type, and purpose
- Mark which files are recommended for users (usually complete and simple versions)
- Prepare download URLs for each file so users can access them

**Understanding File Purposes**:
- **Simple files**: Basic book content with smaller file size, good for quick access
- **Complete files**: Full book with all metadata included, recommended for most uses
- **Alternative files**: Different resource types or experimental versions, use with caution
- **Unknown files**: If you can't categorize a file, treat it carefully and let users decide

### 5. Tool Data Integration

**How to Access translationCore App Data**:

**Step 1: Check if Tool Data Directory Exists**
- Look for a directory named `.apps/translationCore` in the repository
- If it doesn't exist, the repository doesn't have additional tool data

**Step 2: Explore the Tool Data Structure**
- The `.apps/translationCore` directory contains subdirectories for different types of data:
  - `alignmentData/{book}/` - Word alignment information for the book
  - `checkData/` - Quality assurance check results organized by tool
  - `selectionsData/` - User selections and highlights organized by tool

**Step 3: Check What Data is Available**
- Try to access each subdirectory to see if it contains data
- If `alignmentData/{book}/` has content, word alignment features are available
- If `checkData/` has content, quality check results are available
- If `selectionsData/` has content, user selection data is available

**Step 4: Handle Missing Data Gracefully**
- If you can't access the `.apps` directory, it might not exist or be empty
- Don't treat this as an error - just note that additional features aren't available
- The main USFM content is still usable without the tool data

**Step 5: Organize the Available Features**
- Make note of which additional features are available in this repository
- This helps you decide what functionality to offer users in your application

## Differences from Resource Container

| Aspect | Resource Container | translationCore |
|--------|-------------------|-----------------|
| **Scope** | Complete Bible (66 books) | Single book |
| **Manifest** | `manifest.yaml` with `dublin_core` | `manifest.json` with `project`/`resource` |
| **File Pattern** | `01-GEN.usfm`, `02-EXO.usfm` | `jon.usfm`, `es-419_glt_jon_book.usfm` |
| **Dependencies** | `dublin_core.relation[]` | `tsv_relation[]` |
| **Structure** | `projects[]` array | Single `project` object |
| **Tool Info** | Generic RC metadata | translationCore-specific fields |

## Application Integration

### For Preview Applications

**How to Handle translationCore Repositories in Preview Applications**:
- Display the repository as a "translationCore Project" type
- Show the book name from `manifest.project.name`
- Show the target language from `manifest.target_language.name`
- Show the resource type from `manifest.resource.name`
- List all available USFM files for user selection
- Make it clear this is a single book, not a complete Bible

### How to Handle translationCore Repositories in Editing Applications

**Step 1: Set Up Project Information**
- Use the project ID from `manifest.project.id` for internal tracking
- Use the target language ID from `manifest.target_language.id` for language settings
- Use the resource type from `manifest.resource.id` for resource classification

**Step 2: Configure Source References**
- Set up access to source materials listed in `manifest.tsv_relation`
- These are the resources the translator is working from

**Step 3: Prepare Editable Files**
- Make all the USFM files available for editing
- Allow users to choose which version to edit (simple, complete, or alternative)

**Step 4: Check Tool Compatibility**
- Note the minimum compatible version from `manifest.tc_min_compatible_version`
- Note the editing version from `manifest.tc_edit_version`
- Ensure your application supports these versions

## Best Practices

### 1. Format Detection
- Always check manifest content, not just filename
- Look for `tc_version` or `generator.name` fields
- Distinguish from Resource Container format

### 2. File Handling
- Expect multiple USFM files for same book
- Use repository file listing for discovery
- Handle various naming patterns

### 3. Dependency Processing
- Use `tsv_relation` field for dependencies
- Parse version specifications (e.g., `?v=2.1.30`)
- Map to standard resource identifiers

### 4. Tool Compatibility
- Respect `tc_min_compatible_version`
- Consider `tc_edit_version` for editing features
- Handle tool-specific metadata appropriately

## Complete Processing Example

### How to Handle a translationCore Repository in Your Application

**Step 1: Get Repository Information**
- Use the Door43 API to get basic information about the repository
- This tells you the repository name, description, size, and when it was last updated

**Step 2: Get the File Structure**
- Get a complete list of all files and directories in the repository
- This shows you what content is available to work with

**Step 3: Read the Manifest**
- Find and download the manifest file (manifest.json, manifest.yaml, etc.)
- If the content is encoded, decode it first
- Parse the content as JSON or YAML depending on the file extension

**Step 4: Verify It's translationCore**
- Check if the manifest has `tc_version` or if `generator.name` contains "tc-"
- If it doesn't match these patterns, it's not a translationCore repository

**Step 5: Extract Project Details**
- Get the book information from `manifest.project` (ID and name)
- Get the resource information from `manifest.resource` (type and name)  
- Get the target language from `manifest.target_language`
- Get the tool information from `manifest.generator`
- Note the translationCore version from `manifest.tc_version`

**Step 6: Find and Organize the Content Files**
- Use the file discovery steps from earlier to find all USFM files
- Categorize them as simple, complete, or alternative versions

**Step 7: Choose the Best Content File**
- If there's a complete version (with "_book" in the name), use that
- Otherwise, use the simple version (just the book name)
- Fall back to alternative files if needed

**Step 8: Check for Additional Features**
- Look for tool data in the `.apps` directory if it exists
- Check for settings files that might contain user preferences

**Step 9: Prepare the Information for Your App**
- You now have everything needed to display or edit the translation
- You know what type of content it is, where the files are, and what features are available

**How to Choose the Best Content File**:

**Priority 1: Complete Version**
- If you found a file with "_book" in the name, use that one
- This is the most comprehensive version with all metadata

**Priority 2: Simple Version**  
- If there's no complete version, use the file named just "{book}.usfm"
- This is the basic version that should have the main content

**Priority 3: Alternative Files**
- If neither of the above exist, use the first alternative file you found
- These might be experimental versions or different resource types

**What to Do If No Files Found**
- If none of the above exist, there's a problem with the repository
- It might not actually be a translationCore repository, or the files might be organized differently

### How to Display translationCore Resources in Preview Apps

**Step 1: Create the Display Title**
- Combine the book name and resource name for a clear title
- Example: "Jonah (Gateway Language Translation)"
- Include the target language name so users know what language it's in

**Step 2: Organize the Content Files for Display**
- Show all the USFM files you found, with their file types
- Mark which file is recommended (usually the complete version)
- Include file sizes so users know what they're downloading

**Step 3: Show Available Features**
- If the repository has tool data (`.apps` directory), mention available features:
  - Word alignment data (if present)
  - Quality check results (if present)  
  - User selections and highlights (if present)

**Step 4: Display Dependencies**
- Show the related resources from `tsv_relation`
- This helps users understand what other resources work with this one

**Step 5: Present Everything Clearly**
- Make it clear this is a single book, not a complete Bible
- Show the completion status if available
- Provide easy access to download the content files

### How to Set Up translationCore Resources in Editing Apps

**Step 1: Choose the Main Content File**
- Use the primary content file you identified earlier (usually the complete version)
- This will be the main file your users edit

**Step 2: Set Up the Editor Configuration**
- Configure your editor with the book ID, resource type, and target language
- Set the main file name and content URL for loading
- This gives your editor the basic information it needs

**Step 3: Configure Source Material Access**
- Set up access to the dependencies listed in `tsv_relation`
- Configure access to source translations for reference
- This lets users see the original material they're translating from

**Step 4: Configure Tool Compatibility**
- Note which version of translationCore created this repository
- Ensure your app is compatible with that version
- Set any version-specific features or limitations

**Step 5: Enable Available Features**
- If word alignment data exists, enable alignment features in your editor
- If quality check data exists, show check results to users
- If user selection data exists, restore previous user highlights

**Step 6: Prepare Everything for the User**
- Your editing interface now has all the information it needs
- Users can edit the translation with full context and features available

## Analysis Results Summary

Based on examination of [es-419_glt_jon_book](https://git.door43.org/abelper8/es-419_glt_jon_book):

### Key Findings

**Repository Characteristics**:
- ✅ Single book focus (Jonah)
- ✅ Multiple USFM file variations
- ✅ translationCore-specific manifest format
- ✅ Tool data directory (.apps/)
- ✅ Word alignment data present

**File Organization**:
- **Primary content**: Multiple USFM files for same book
- **Tool data**: Organized in .apps/translationCore/ subdirectories
- **Configuration**: settings.json for app preferences
- **Standard files**: LICENSE.md, manifest.json

**Content Quality**:
- **Word alignment**: Extensive alignment markers in USFM
- **USFM compliance**: Standard 3.0 markers
- **Metadata**: Rich project and resource information
- **Dependencies**: Clear source translation references

### Recommendations for Developers

1. **Always check manifest content** - Don't assume format from filename
2. **Handle multiple USFM files** - Implement file priority logic
3. **Process tool data separately** - .apps/ directory is optional but valuable
4. **Use tsv_relation for dependencies** - Different field name than RC format
5. **Expect single book scope** - Don't assume complete Bible

---

This documentation is based on analysis of real translationCore repositories including [es-419_glt_jon_book](https://git.door43.org/abelper8/es-419_glt_jon_book) and should be used alongside the main [Door43 API Developer Guide](../door43-api-developer-guide.md).
